# OS

## 寄存器

-   通用寄存器
    -   %rax    返回值
    -   %rbx    被调用者保存
    -   %rcx    第4个参数
    -   %rdx    第三个参数
    -   %rsi     第2个参数
    -   %rdi    第1个参数
    -   %rbp    被调用者保存
    -   %rsp    栈指针
    -   %r8    第5个参数
    -   %r9    第6个参数
    -   %r10    调用者保存
    -   %r11    调用者保存
    -   %r12    被调用者保存
    -   %r13    被调用者保存
    -   %r14    被调用者保存
    -   %r15    被调用者保存
-   堆栈指针寄存器
    -   %rbp    标示当前栈桢的起始位置
    -   %rsp    标示当前栈桢的顶部
-   指令指针寄存器
    -   %rip    存储现在正在被运行的指令
-   变址寄存器
    -   %rsi    源变址寄存器
    -   %rdi    目的变址寄存器
-   段寄存器
-   标志寄存器

### 操作数类型

-   立即数
-   寄存器
-   内存引用

<font color=red>寻址模式</font>

| 类型   | 格式                               | 操作数数值                                       | 名称                |
| ------ | ---------------------------------- | ------------------------------------------------ | ------------------- |
| 立即数 | $Imm                               | Imm                                              | 立即数寻址          |
| 寄存器 | r<sub>a</sub>                      | R[r<sub>a</sub>]                                 | 寄存器寻址          |
| 存储器 | Imm                                | M[Imm]                                           | 绝对寻址            |
| 存储器 | (r<sub>a</sub>)                    | M[R[r<sub>a</sub>]]                              | 间接寻址            |
| 存储器 | Imm(r<sub>b</sub>)                 | M[Imm + R[r<sub>b</sub>]]                        | （基址+偏移量）寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>)      | M[R[r<sub>b</sub>] + R[r<sub>i</sub>]]           | 变址寻址            |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>)   | M[Imm + R[r<sub>b</sub>] + R[r<sub>i</sub>]]     | 变址寻址            |
| 存储器 | (,r<sub>i</sub>,s)                 | M[R[r<sub>i</sub>] * s]                          | 比例变址寻址        |
| 存储器 | Imm(,r<sub>i</sub>,s)              | M[Imm + R[r<sub>i</sub>] * s]                    | 比例变址寻址        |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>,s)    | M[R[r<sub>b</sub>] + R[r<sub>i</sub>] * s]       | 比例变址寻址        |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>,s) | M[Imm + R[r<sub>b</sub>] + R[r<sub>i</sub>] * s] | 比例变址寻址        |

## 过程

常规意义上的函数，用一组指定的参数和一个可选的返回值实现了某种功能

假设P调用Q，Q执行完后返回到P，必须支持以下机制

-   传递控制，在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址
-   传递数据，P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值
-   分配和释放内存，在开始是，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间

### 栈结构的信息记忆

<font color=red>栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息，当P调用Q时，控制和数据信息添加到栈尾，当P返回时，这些信息会释放掉，栈底是高地址，栈顶是低地址，使用pushq和popq指令将数据存入栈中或是从栈中取出</font>

作用

-   传递参数
-   存储返回信息
-   保存寄存器
-   局部存储

当过程P调用过程Q，会把返回地址压入栈中，指明当调用返回时应该执行的下一条指令，<font color=red>这个返回地址是P栈桢的一部分，因为存储的是与P相关的状态</font>，

### 过程的栈桢

<font color=red>当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这部分称为过程的栈桢</font>

### 转移控制

指令call Q会把地址A压入栈中，并将PC设置为Q的起始地址，地址A是紧跟在call指令后面的那条指令的地址

ret指令会从栈中弹出地址A，并把PC设为A



## 中断

<font color=red>处理器接收到来自硬件或者软件的信号，提示发生了某个事件，应该被注意</font>

中断类型

-   硬件中断

    -   可屏蔽中断
    -   非可屏蔽中断

-   软件中断

    <font color=red>一条CPU指令，用以自陷入一个中断。由于软中断指令通常要运行一个切换CPU至内核态的子例程，它常用来实现系统调用</font>

    

## 系统调用

### 什么是操作系统接口？

系统调用，表现为函数调用，由于是操作系统提供的，所以称为系统调用

### 操作系统接口连接的是什么？

连接的是操作系统与应用软件

### 系统调用的核心

-   <font color=red>用户程序中包含一段含int指令的代码，由库函数实现</font>
-   <font color=red>操作系统写中断处理，获取想调程序的编号</font>
-   <font color=red>操作系统根据编号执行相应代码</font>



## 进程与线程

### 进程

#### 进程的概念

<font color=red>进程=资源+指令执行序列</font>

<font color=red>一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值，它是操作系统分配资源的基本单位</font>



#### 进程的状态

1.  <font color=red>运行态</font>
2.  <font color=red>就绪态</font>
3.  <font color=red>阻塞态</font>

#### 多个进程使用CPU的图像

-   如何使用CPU
    -   让程序执行起来，CPU就是取址执行，循环往复
-   如何充分利用CPU
    -   启动多个程序，交替执行
-   启动了的程序就是进程，所以是多个进程推进
    -   操作系统只需要把这些进程记录好，按照合理的次序推进
    -   这就是多进程图像

#### 如何组织多进程

<font color=red>PCB+状态+队列</font>

#### 多进程如何切换

<font color=red>队列操作+调度+切换</font>

#### 多进程地址空间可能冲突

<font color=red>引入内存管理，形成进程间地址隔离，避免冲突，构建多进程图像时也带动了内存管理图像的构建</font>

#### 多进程合作需要进程间同步

##### 为什么需要多进程间合作时需要进程间同步

<font color=red>若不同步，多进程合作时若共同操作同一内存区域可能产生不稳定的结果，例如生产者、消费者问题，因为一条代码可能是多条指令组成的，这是非原子操作的，当一个进程执行某条指令对共享内存区域执行操作时，因为是多进程图像，可能随时发生调度切换到令一个进程，那么便会产生意想不到的结果，所以需要进程间同步，协调好推进顺序</font>



#### <font color=red>如何形成多进程图形</font>

-   <font color=red>读写PCB    数据结构</font>
-   <font color=red>要操作寄存器完成切换</font>
-   <font color=red>要写调度程序    进程调度算法</font>
-   <font color=red>要有进程同步与合作    锁、信号量</font>
-   <font color=red>要有地址映射    内存管理范围</font>    

####  进程间通信

三个重要问题

-   以进程如何把信息传递给另一个进程
-   进程同步问题
-   正确的关联顺序

竞争条件

<font color=red>两个或多个进程读写某些共享数据时，最后结果取决于进程运行的精确时序</font>

如何避免竞争条件？

<font color=red>关键是要找出某种途径来组织多个进程同时读写共享的数据，即进程互斥，确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作</font>

<font color=green>临界区</font>

对共享内存进行访问的程序片段

<font color=red>互斥的实现方案</font>

-   屏蔽中断
-   锁变量
-   严格轮换法
-   Peterson解法
-   TSL指令
-   睡眠与唤醒
-   <font color=red>信号量</font>
-   互斥量



<font color=red>进程间通信的方式</font>

-   管道
-   消息队列
-   信号量
-   共享内存
-   socket套接字





### 线程

##### 线程的概念

<font color=red>操作系统进行任务调度的基本单位，进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体</font>

#### 进程中是否可以资源不动而切换指令执行序列

-   将资源和指令执行分开
-   一个资源 + 多个指令执行序列

<font color=red>答案就是线程</font>

-   <font color=red>线程保留了并发的优点，避免了进程切换代价</font>
-   <font color=red>实质就是映射表不变而PC指针变</font>

#### 线程优点

-   在许多任务中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞，通过将程序分解为可以准并行的多个顺序线程，程序设计模型会变得简单
-   线程比进程更轻量级，更容易创建与撤销
-   如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快应用程序的执行速度

#### 线程概念的目的

共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作

#### 线程共享的内容

-   地址空间
-   全局变量
-   打开文件
-   子进程
-   即将发生的定时器
-   信号与信号处理程序
-   账户信息

#### 线程自己的内容

-   程序计数器
-   寄存器
-   堆栈
-   状态



#### <font color=red>用户级线程的具体实现方式</font>

-   <font color=red>两个TCB</font>
-   <font color=red>两个栈</font>
-   <font color=red>切换的PC在栈中</font>

ThreadCreate的核心就是做出这三样东西

```c
void ThreadCreate(A)
{
    TCB *tcb = malloc();
    *stack = malloc();
    *stack = A;
    tcb.esp = stack;
}
```

##### 用户级线程与内核级线程

<font color=red>分类标准主要是线程的调度者是在内核内还是在内核外</font>

###### 用户级线程

<font color=red>有关线程的管理工作都是由应用程序完成，内核意识不到用户级线程的存在，也不会对这些用户级线程进行调度，所以用户级线程无法利用CPU的多核</font>

内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行

<font color=blue>优点</font>

-   用户级线程的切换是由用户程序控制的，因此不需要为了线程管理切换到内核态，因此节省了状态转换的开销
-   用户级线程可以在任何操作系统上运行，不需要对底层内核进行修改以支持用户级线程

<font color=blue>缺点</font>

-   当用户级线程执行一个系统调用时，如果这个线程被阻塞，进程中的所有线程都会被阻塞
-   用户级线程无法利用多处理器



#### <font color=red>内核级线程的具体实现方式</font>

-   <font color=red>两个TCB</font>
-   <font color=red>两套栈</font>
-   <font color=red>TCB关联内核栈</font>

###### 内核级线程

<font color=red>内核级线程是指由内核管理，只运行在内核态、不受用户上下文拖累的线程，其依赖操作系统的核心，由内核的内部需求进行创建和撤销。内核线程的线程表位于内核中，包括了线程控制块，一旦线程阻塞，内核会从当前进程中重新选择一个线程保证程序的运行。用户应用通过API和系统调用来访问内核级线程</font>

<font color=blue>优点</font>

-   如果进程中的一个线程被阻塞，内核可以调度同一个进程的另一个线程
-   <font color=red>内核可以把同一个进程的多个线程调度到多个处理器</font>

<font color=blue>缺点</font>

-   把控制从一个线程传送到同一个进程的另一个线程时，需要到内核进行装态切换，造成系统开销























### Linux进程调度算法

<font color=red>总的原则是让操作系统专注于任务执行，又能合理调配任务</font>

####  让进程满意的调度算法应该满足哪些要求

-   尽快结束任务：<font color=red>周转时间短（从任务进入到任务结束）</font>
-   用户操作尽快相应：响应时间短<font color=red>（从操作发生到相应）</font>
-   系统内耗时间少：吞吐量（完成的任务量）

#### 如何做到合理？

-   吞吐量和响应时间之间有矛盾
    -   响应时间小->切换次数多->系统内耗大->吞吐量小
-   前台任务与后台任务的关注点不同
    -   前台任务关注响应时间，后台任务关注周转时间
-   IO约束型任务和CPU约束型任务有各自的特点



-   FCFS(first come,first served)
    -   优点
        -   简单有效
    -   缺点
        -   周转时间长
-   SJF(短作业优先)   
    -   优点
        -   周转时间短
    -   缺点
        -   无法考虑到响应时间
        -   长作业的运行得不到保证
-   RR(按时间片来轮转调度)
    -   优点
        -   考虑到了前台任务需要响应时间小的需求
    -   缺点
        -   响应时间变小，但是系统内耗增大，导致吞吐量减小
        -   没有考虑到系统中多种类型任务的资源需求



#### 前台任务与后台任务同时存在时的直观解决方法

<font color=red>直观想法</font>：定义前台任务和后台任务两队列，前台RR，后台SJF，只有前台任务没有时才调度后台任务

可能出现的问题

-   后台任务可能一直得不到运行
-   后台任务优先级动态升高，但后台任务一旦执行，前台的响应时间变长
-   前后台都是用RR，退化为RR
-   如何定义前台任务与后台任务
-   前台任务也可能执行一些耗时的计算工作，后台任务也会有一些需要响应时间短的操作
-   SJF的短作业优先需要未来的信息



#### 一个实际的调度函数-Linux0.11

```c
// linux-0.11/kernel/sched.c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
		}
    
    /* this is the scheduler proper: */
    /**
    这部分代码的目的是在所有就绪状态的任务进程中筛选出counter值最大的进程ID，如果counter值不为0则调度这个进程执行，如果counter值为0，则说明所有就绪态的进程的时间片都已经用完，需要重新调整所有进程的时间片
    **/

	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
			{
				(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
			}
	}
	switch_to(next);
}
```



### Linux进程地址空间

-   代码段
-   数据段
-   堆
-   共享库的内存映射区域
-   栈
-   内核内存空间





## 内存管理





## 文件系统





## 输入输出





