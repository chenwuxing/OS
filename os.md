# OS

## 寄存器

-   通用寄存器
    -   %rax    返回值
    -   %rbx    被调用者保存
    -   %rcx    第4个参数
    -   %rdx    第三个参数
    -   %rsi     第2个参数
    -   %rdi    第1个参数
    -   %rbp    被调用者保存
    -   %rsp    栈指针
    -   %r8    第5个参数
    -   %r9    第6个参数
    -   %r10    调用者保存
    -   %r11    调用者保存
    -   %r12    被调用者保存
    -   %r13    被调用者保存
    -   %r14    被调用者保存
    -   %r15    被调用者保存
-   堆栈指针寄存器
    -   %rbp    标示当前栈桢的起始位置
    -   %rsp    标示当前栈桢的顶部
-   指令指针寄存器
    -   %rip    存储现在正在被运行的指令
-   变址寄存器
    -   %rsi    源变址寄存器
    -   %rdi    目的变址寄存器
-   段寄存器
-   标志寄存器

### 操作数类型

-   立即数
-   寄存器
-   内存引用

<font color=red>寻址模式</font>

| 类型   | 格式                               | 操作数数值                                       | 名称                |
| ------ | ---------------------------------- | ------------------------------------------------ | ------------------- |
| 立即数 | $Imm                               | Imm                                              | 立即数寻址          |
| 寄存器 | r<sub>a</sub>                      | R[r<sub>a</sub>]                                 | 寄存器寻址          |
| 存储器 | Imm                                | M[Imm]                                           | 绝对寻址            |
| 存储器 | (r<sub>a</sub>)                    | M[R[r<sub>a</sub>]]                              | 间接寻址            |
| 存储器 | Imm(r<sub>b</sub>)                 | M[Imm + R[r<sub>b</sub>]]                        | （基址+偏移量）寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>)      | M[R[r<sub>b</sub>] + R[r<sub>i</sub>]]           | 变址寻址            |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>)   | M[Imm + R[r<sub>b</sub>] + R[r<sub>i</sub>]]     | 变址寻址            |
| 存储器 | (,r<sub>i</sub>,s)                 | M[R[r<sub>i</sub>] * s]                          | 比例变址寻址        |
| 存储器 | Imm(,r<sub>i</sub>,s)              | M[Imm + R[r<sub>i</sub>] * s]                    | 比例变址寻址        |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>,s)    | M[R[r<sub>b</sub>] + R[r<sub>i</sub>] * s]       | 比例变址寻址        |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>,s) | M[Imm + R[r<sub>b</sub>] + R[r<sub>i</sub>] * s] | 比例变址寻址        |

## 过程

常规意义上的函数，用一组指定的参数和一个可选的返回值实现了某种功能

假设P调用Q，Q执行完后返回到P，必须支持以下机制

-   传递控制，在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址
-   传递数据，P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值
-   分配和释放内存，在开始是，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间

### 栈结构的信息记忆

<font color=red>栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息，当P调用Q时，控制和数据信息添加到栈尾，当P返回时，这些信息会释放掉，栈底是高地址，栈顶是低地址，使用pushq和popq指令将数据存入栈中或是从栈中取出</font>

作用

-   传递参数
-   存储返回信息
-   保存寄存器
-   局部存储

当过程P调用过程Q，会把返回地址压入栈中，指明当调用返回时应该执行的下一条指令，<font color=red>这个返回地址是P栈桢的一部分，因为存储的是与P相关的状态</font>，

### 过程的栈桢

<font color=red>当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这部分称为过程的栈桢</font>

### 转移控制

指令call Q会把地址A压入栈中，并将PC设置为Q的起始地址，地址A是紧跟在call指令后面的那条指令的地址

ret指令会从栈中弹出地址A，并把PC设为A



## 中断

<font color=red>处理器接收到来自硬件或者软件的信号，提示发生了某个事件，应该被注意</font>

中断类型

-   硬件中断

    -   可屏蔽中断
    -   非可屏蔽中断

-   软件中断

    <font color=red>一条CPU指令，用以自陷入一个中断。由于软中断指令通常要运行一个切换CPU至内核态的子例程，它常用来实现系统调用</font>

    

## 系统调用

### 什么是操作系统接口？

系统调用，表现为函数调用，由于是操作系统提供的，所以称为系统调用

### 操作系统接口连接的是什么？

连接的是操作系统与应用软件

### 系统调用的核心

-   <font color=red>用户程序中包含一段含int指令的代码，由库函数实现</font>
-   <font color=red>操作系统写中断处理，获取想调程序的编号</font>
-   <font color=red>操作系统根据编号执行相应代码</font>



## 进程与线程

### 进程

#### 进程的概念

<font color=red>进程=资源+指令执行序列</font>

<font color=red>一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值，它是操作系统分配资源的基本单位</font>

#### 进程的状态

1.  <font color=red>运行态</font>
2.  <font color=red>就绪态</font>
3.  <font color=red>阻塞态</font>

#### 多个进程使用CPU的图像

-   如何使用CPU
    -   让程序执行起来，CPU就是取指执行，循环往复
-   如何充分利用CPU
    -   启动多个程序，交替执行
-   启动了的程序就是进程，所以是多个进程推进
    -   操作系统只需要把这些进程记录好，按照合理的次序推进
    -   这就是多进程图像

#### 如何组织多进程以及切换进程

-   <font color=red>PCB+状态+队列</font>
-   <font color=red>队列操作+调度+切换</font>
-   <font color=red>引入内存管理，形成进程间地址隔离，避免冲突，构建多进程图像时也带动了内存管理图像的构建</font>  资源的切换

#### 如何形成多进程图形

-   <font color=red>读写PCB    数据结构</font>
-   <font color=red>要操作寄存器完成切换</font>
-   <font color=red>要写调度程序    进程调度算法</font>
-   <font color=red>要有进程同步与合作    锁、信号量</font>
-   <font color=red>要有地址映射    内存管理范围</font>    



#### 进程同步、互斥、通信

<font color=blue>在多道程序设计系统中，同一时刻可能有许多进程，这些进程之间存在两种基本关系：竞争关系和协作关系，进程的互斥、同步、通信都是基于这两种基本关系而存在的，为了解决进程间竞争关系（间接制约关系）而引入进程互斥；为了解决进程间**松散的协作**关系( **直接制约关系**)而引入进程同步；为了解决进程间**紧密的协作**关系而引入进程通信</font>



#####  进程间通信

进程间通信的目的

-   数据传输

    一个进程需要将它的数据发送给另一个进程

-   共享数据

    多个进程想要操作共享数据，需要进程间互斥

-   通知事

    一个进程需要向另一个或一组进程发送消息，通知它发生了某种事件（如进程终止时要通知父进程）

-   资源共享

    多个进程之间共享同样的资源，为了做到这一点，需要内核提供锁和同步机制

-   进程控制

    有些进程希望完全控制另一个进程的执行，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并且能够及时知道它的状态改变

<font color=red>进程间通信的方式</font>

-   管道

    缺点

    -   半双工的通信，数据只能单向流动
    -   只能在具有亲缘关系的进程间使用

-   FIFO

    -   克服管道的只能具有亲缘关系的进程间才能通信的缺点
    -   速度慢

-   信号

    -   比较复杂的通信方式，用于通知接收进程某个事件已经发生
    -   主要作为进程间以及同一进程不同线程之间的同步手段

    信号的处理：

    -   忽略此信号，大多数信号都可以使用这种方式进行处理，但是SIGKILL和SIGSTOP不可以
    -   捕捉信号，为了做到这一点，需要通知内核在某种信号发生时，调用一个用户函数，在用户函数中，可执行用户希望对这种事件进行的处理
    -   执行系统默认动作

-   消息队列

    -   消息的链表，存放在内核中并由消息队列标示符标示
    -   克服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点
    -   容量收到系统限制，且要注意第一次读的时候要考虑上一次没有读完数据的问题

-   共享内存

    -   映射一段能被其他进程所访问的内存

-   信号量

    -   一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，主要作为进程间以及不同线程间的同步手段
    -   不能用来传递复杂消息，只能用来同步

-   socket套接字

    -   可用于不同机器间的进程通信



##### 进程间同步

为什么需要多进程间合作时需要进程间同步？

<font color=red>若不同步，多进程合作时若共同操作同一内存区域可能产生不稳定的结果，例如生产者、消费者问题，因为一条代码可能是多条指令组成的，这是非原子操作的，当一个进程执行某条指令对共享内存区域执行操作时，因为是多进程图像，可能随时发生调度切换到令一个进程，那么便会产生意想不到的结果，所以需要进程间同步，协调好推进顺序</font>

##### 进程互斥

对临界资源的访问，需要互斥的进行，即同一时间段内只允许一个进程访问该资源

四个部分

-   进入区
-   临界区
-   退出区
-   剩余区

需要遵循的原则：

-   空闲让进
-   忙则等待
-   有限等待
-   让权等待

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

进程互斥的实现方法

软件实现：

1.  单标志法
    -   在进入区只做检查，不上锁
    -   不遵循空闲让进原则
2.  双标志先检查
    -   在进入区先检查后上锁，退出区解锁
    -   不遵循忙则等待原则
3.  双标志后检查
    -   在进入区先加锁后检查，退出区解锁
    -   不遵循空闲让进，有限等待等原则
4.  peterson算法
    -   在进入区主动争取-主动谦让-检查对方是否想进、己方是否谦让
    -   不遵循让权等待原则，会发生忙等

硬件实现：

1.  中断屏蔽法
2.  TestAndSet
3.  Swap指令

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

生产者消费者

![image-20200802161911881](/home/wuxing/.config/Typora/typora-user-images/image-20200802161911881.png)



多生产者多消费者

![image-20200802163248480](/home/wuxing/.config/Typora/typora-user-images/image-20200802163248480.png)



吸烟问题

![image-20200802165047637](/home/wuxing/.config/Typora/typora-user-images/image-20200802165047637.png)

<font color=red>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系，在分析同步问题(一前一后问题)的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系</font>



#### 死锁

在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象

死锁、饥饿、死循环的区别

![image-20200802170059520](/home/wuxing/.config/Typora/typora-user-images/image-20200802170059520.png)

死锁产生的必要条件

1.  互斥条件
2.  不可剥夺条件
3.  请求保持条件
4.  循环等待条件

银行家算法步骤

1.  检查此次申请是否超过了之前声明的最大需求数
2.  检查此时系统剩余的可用资源是否还能满足这次请求
3.  试探着分配，更改数据结构
4.  用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法步骤：

1.  检查当前剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全性序列，并把该进程持有的资源全部回收
2.  不断重复上述过程，看最终是否能让所有进程都加入安全序列



#### <font color=red>进程常见面试题</font>

1.  什么是孤儿进程与僵尸进程
    -   孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程，孤儿进程将被1号进程领养，并由1号进程对它们完成状态收集工作
    -   僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程
    -   问题及危害：unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，便可以得到。这段保留的状态信息直到父进程通过wait/waitpid来取时才会释放，<font color=red>如果进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，这便是僵尸进程的危害</font>
    -   孤儿进程因为会被领养的原因，所以会正确的结束其生命周期，所以并不会有什么危害

<font color=blue>僵尸进程解决方法</font>：

-   信号机制

    子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号，在信号处理函数中调用wait处理僵尸进程

-   fork两次

    原理是将子进程成为孤儿进程，从而其父进程变为init进程，通过init进程可以处理僵尸进程

2.  fork、vfork以及clone的区别

    vfork与fork的区别是vfork共享父进程的地址空间，vfork之后父进程会让子进程先运行，因为vfork主要用于为了让子进程exec，exec之后子进程会用新程序的数据将内存重新刷一遍，这样它就有了自己的地址空间，子进程exec之后，会向父进程发送信号，这个时候父进程就可以开始运行了，如果子进程修改了父进程地址空间的数据的话，父进程唤醒后会发现自己数据被改了，完整性丢失。

    clone和fork的最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 线程

##### 线程的概念

<font color=red>操作系统进行任务调度的基本单位，进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体</font>

#### 进程中是否可以资源不动而切换指令执行序列

-   将资源和指令执行分开
-   一个资源 + 多个指令执行序列

<font color=red>答案就是线程</font>

-   <font color=red>线程保留了并发的优点，避免了进程切换代价</font>
-   <font color=red>实质就是映射表不变而PC指针变</font>

#### 线程优点

-   在许多任务中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞，通过将程序分解为可以准并行的多个顺序线程，程序设计模型会变得简单
-   线程比进程更轻量级，更容易创建与撤销
-   如果存在着大量的计算和大量的IO处理，拥有多个线程允许这些活动彼此重叠进行，加快应用程序的执行速度

#### 线程概念的目的

共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作

#### 线程共享的内容

-   地址空间
-   全局变量
-   打开文件
-   子进程
-   即将发生的定时器
-   信号与信号处理程序
-   账户信息

#### 线程自己的内容

-   程序计数器
-   寄存器
-   堆栈
-   状态



#### <font color=red>用户级线程的具体实现方式</font>

-   <font color=red>两个TCB</font>
-   <font color=red>两个栈</font>
-   <font color=red>切换的PC在栈中</font>

ThreadCreate的核心就是做出这三样东西

```c
void ThreadCreate(A)
{
    TCB *tcb = malloc();
    *stack = malloc();
    *stack = A;
    tcb.esp = stack;
}
```

##### 用户级线程与内核级线程

<font color=red>分类标准主要是线程的调度者是在内核内还是在内核外</font>

###### 用户级线程

<font color=red>有关线程的管理工作都是由应用程序完成，内核意识不到用户级线程的存在，也不会对这些用户级线程进行调度，所以用户级线程无法利用CPU的多核</font>

内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行

<font color=blue>优点</font>

-   用户级线程的切换是由用户程序控制的，因此不需要为了线程管理切换到内核态，因此节省了状态转换的开销
-   用户级线程可以在任何操作系统上运行，不需要对底层内核进行修改以支持用户级线程

<font color=blue>缺点</font>

-   当用户级线程执行一个系统调用时，如果这个线程被阻塞，进程中的所有线程都会被阻塞
-   用户级线程无法利用多处理器



#### <font color=red>内核级线程的具体实现方式</font>

-   <font color=red>两个TCB</font>
-   <font color=red>两套栈</font>
-   <font color=red>TCB关联内核栈</font>

###### 内核级线程

<font color=red>内核级线程是指由内核管理，只运行在内核态、不受用户上下文拖累的线程，其依赖操作系统的核心，由内核的内部需求进行创建和撤销。内核线程的线程表位于内核中，包括了线程控制块，一旦线程阻塞，内核会从当前进程中重新选择一个线程保证程序的运行。用户应用通过API和系统调用来访问内核级线程</font>

<font color=blue>优点</font>

-   如果进程中的一个线程被阻塞，内核可以调度同一个进程的另一个线程
-   <font color=red>内核可以把同一个进程的多个线程调度到多个处理器</font>

<font color=blue>缺点</font>

-   把控制从一个线程传送到同一个进程的另一个线程时，需要到内核进行装态切换，造成系统开销

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Linux调度算法

|                      | 要做什么                                                     | 调度发生在              | 发生频率 | 对进程状态的影响                    |
| -------------------- | ------------------------------------------------------------ | ----------------------- | -------- | ----------------------------------- |
| 高级调度（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存-》内存（面向作业） | 最低     | 无-》创建态-》就绪态                |
| 中级调度（内存调度） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存-》内存（面向进程） | 中等     | 挂起态-》就绪态   阻塞挂起-》阻塞态 |
| 低级调度（进程调度） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存-》cpu              | 最高     | 就绪态-》运行态                     |

####  让进程满意的调度算法应该满足哪些要求

-   尽快结束任务：<font color=red>周转时间短（从任务进入到任务结束）</font>
-   用户操作尽快相应：响应时间短<font color=red>（从操作发生到相应）</font>
-   系统内耗时间少：吞吐量（完成的任务量）

#### 如何做到合理？

-   吞吐量和响应时间之间有矛盾
    -   响应时间小->切换次数多->系统内耗大->吞吐量小
-   前台任务与后台任务的关注点不同
    -   前台任务关注响应时间，后台任务关注周转时间
-   IO约束型任务和CPU约束型任务有各自的特点

![](/home/wuxing/Pictures/Work/调度算法指标.png)



-   FCFS(first come,first served)
    -   优点
        -   简单有效
    -   缺点
        -   周转时间长
-   SJF(短作业优先)   
    -   优点
        -   周转时间短
    -   缺点
        -   无法考虑到响应时间
        -   长作业的运行得不到保证
-   RR(按时间片来轮转调度)
    -   优点
        -   考虑到了前台任务需要响应时间小的需求
    -   缺点
        -   响应时间变小，但是系统内耗增大，导致吞吐量减小
        -   没有考虑到系统中多种类型任务的资源需求
-   优先级调度算法
    -   优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
    -   缺点：若源源不断地有高优先级进程到来，则可能导致饥饿



#### 前台任务与后台任务同时存在时的直观解决方法

<font color=red>直观想法</font>：定义前台任务和后台任务两队列，前台RR，后台SJF，只有前台任务没有时才调度后台任务

可能出现的问题

-   后台任务可能一直得不到运行
-   后台任务优先级动态升高，但后台任务一旦执行，前台的响应时间变长
-   前后台都是用RR，退化为RR
-   如何定义前台任务与后台任务
-   前台任务也可能执行一些耗时的计算工作，后台任务也会有一些需要响应时间短的操作
-   SJF的短作业优先需要未来的信息



#### 一个实际的调度函数-Linux0.11

```c
// linux-0.11/kernel/sched.c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
		}
    
    /* this is the scheduler proper: */
    /**
    这部分代码的目的是在所有就绪状态的任务进程中筛选出counter值最大的进程ID，如果counter值不为0则调度这个进程执行，如果counter值为0，则说明所有就绪态的进程的时间片都已经用完，需要重新调整所有进程的时间片
    **/

	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
			{
				(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
			}
	}
	switch_to(next);
}
```

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 内存管理

根据冯诺依曼的计算机模型，计算机就是不断的取址执行，取址便是去内存中取址，而直观的内存管理工作便是将指令放入内存中，但是这种最原始的内存管理方法有以下缺点

-   指令地址为物理地址，那么程序运行时也要放置在对应的物理内存地址
-   容易引起进程间地址冲突
-   一些位置程序是不能使用到，如内核地址

改进方向：重新定位程序中的地址

1.  编译时重定位，程序只能放置在固定位置，但效率高，适合一些嵌入式程序
2.  载入时重定位，一旦载入内存就不能动了，但现在计算机常有进程换入换出，不适合
3.  运行时重定位，每个进程都有各自的基地址，基地址放在PCB中

所以目前改进得到的方案是在内存中找到一片内存，将程序放置到这片内存，然后置好进程的PCB

<font color=red>但是将整个程序放入一片内存并不容易，可能没有那么大的一片内存</font>

改进方向：内存分段

### 内存分段

程序员中的程序是由若干段组成的，每个段有各自的特点、用途

-   符合用户观点：用户可以独立考虑各个段
-   定位具体指令(数据)：<段号，段内偏移>

<font color=red>将各段分别放入内存</font>

实现方法

-   进程段表
-   将操作系统看成一个进程，那么其对应的进程段表便是GDT表
-   一般的进程段表是LDT表

### 内存分区

作用：为程序段在内存中找出一段内存区域

内存分区实际是一个算法，用来解决内存如何分割的问题，分割好后便可以将程序的各个段载入到相应的内存分区中

-   固定分区，将内存分割为相等大小的区域，不适用
-   可变分区
    -   首先适配
    -   最佳适配
    -   最差适配

数据结构支撑：可以用一个线性表记录内存中还有哪些区域可用

<font color=red>但是内存分区算法会造成大量的内存碎片，浪费系统资源，需要更细粒度的内存分配方法</font>

改进方向：内存分页

### 内存分页

<font color=red>从连续到离散，针对每个段内存请求，系统一页一页的分配给这个段</font>

<font color=blue>采用内存分页，物理内存碎片少，这是物理内存希望的内存分割方法，从用户的角度出发，用户希望用内存分段方便管理程序</font>

所以操作系统即应该支持分段也应该支持分页，即段页结合的内存管理方法

分页方式如何定位？

-   构建页表，建立页号与页框号的映射
-   页号是逻辑地址

### 内存换入

<font color=red>内存分段与分页的粘合剂是虚拟内存，而虚拟内存的实现方法便是内存换入与内存换出</font>

用户可以使用的是“大且规整的虚拟内存空间”，例如32位机，用户可以使用的便是4G内存空间，给用户一个独自占有计算机的感觉，但是这只是虚拟内存，我们最终的目的是将指令加载到物理内存执行，那么关键就是如何<font color=red>实现虚拟内存到物理内存的映射</font>

<font color=red>但是实际的物理内存常常小于虚拟内存大小，如何给用户实现虚拟内存空间均可用的感觉？</font>

请求调入页面建立页面映射！

当访问一个虚拟地址时，查看页表发现缺页，引发缺页中断，执行相应的中断处理程序，为虚拟地址申请空闲页，将虚拟地址对应的磁盘页加载到新分配的物理页，并建立新的页表项映射，中断返回，继续执行引发中断的指令

```c
void do_nopage(unsigned long error_code,unsigned long address)
{
    address &= 0xfffff000;
    tmp = address-current->start_code; // 页面对应的偏移
    if(!current->executable || tmp >= current->end_data)
    {
        get_empty_page(address);
        return;
    }
    page = get_free_page();
    bread_page(page,current->executable->i_dev,nr);
    put_page(page,address);
}
```

### 内存换出

算法评价准则：<font color=red>缺页次数</font>

-   FIFO页面置换
-   MIN算法：选最远将使用的页淘汰，但是需要未来的信息
-   LRU：选最近最长一段时间没有使用的页淘汰
    -   时间戳
    -   页面栈
-   Clock算法
    -   一个指针用来清除R位，移动速度要快
    -   一个指针用来选择淘汰页，移动速度慢



## 文件系统





## 输入输出





